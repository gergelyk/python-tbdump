{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tbdump \u00b6 The aim of this library is to provide an option of post-mortem debugging for the application which would crash on a remote machine, for instance on customer site. Project is influenced by pydump and powered by dill . This also results in some limitations . Faulty Application \u00b6 As an example let's take this code of a simple calculator: import sys def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) It will certainly raise an exception when divisor is 0. python divide.py 5 0 Traceback (most recent call last): File \"divide.py\", line 9, in <module> print(div(x, y)) File \"divide.py\", line 4, in div return x / y ZeroDivisionError: division by zero Traceback Capturing \u00b6 We have following options to take traceback down into a file: We can use tbdump module in place of python interpreter. This will capture any unhandled Exception : python -m tbdump divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl It is suitable when we have a chance to change the way how Python script is invoked. This is also how tbdump can be activated from shebang: #!/usr/bin/env -S python -m tbdump Alternatively we can install tbdump as exception hook using its default implementation: import sys import tbdump tbdump . set_excepthook () def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl Finally, we can customize exception handler by preparing its custom implementation: import sys from tbdump import dump_exception def div ( x , y ): return x / y if __name__ == '__main__' : try : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) except Exception as exc : try : dumpfile = 'traceback.pkl' dump_exception ( exc , dumpfile ) print ( f ' { type ( exc ) . __name__ } : { exc } ' ) print ( f 'Traceback dumped into: { dumpfile } ' ) except Exception : print ( 'Failed to dump traceback' ) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl No matter which option we choose, we should get a traceback.pkl file in case of an exception. Traceback Analysis \u00b6 Some developers may prefer to launch their favourite debugger right away: poetry run python -m tbdebug traceback.pkl tbdebug uses breakpoint() . Behaviour of this function can be adjusted using PYTHONBREAKPOINT variable. Alternatively, simple helper script can be used by hose who would like to apply any preprocessing in prior to that: import tbdump dump = tbdump . load ( 'traceback.pkl' ) # any preprocessing here breakpoint () Last option is for these developers who are familiar with peepshow and may prefer calling it: poetry run python -m tbpeep traceback.pkl Limitations \u00b6 There are a few data types which dill doesn't pickle by definition. At the time of writing these include generator, Frame, Traceback. Note Top-level traceback and corresponding frames are translated into substitutionary objects. Moreover, there are a few open issues with pickling enums and namespace packages . Last but not least, modules which were captured on a remote host but are not available in local environment are substituted by dummy objects in the process of loading dump files.","title":"Overview"},{"location":"#tbdump","text":"The aim of this library is to provide an option of post-mortem debugging for the application which would crash on a remote machine, for instance on customer site. Project is influenced by pydump and powered by dill . This also results in some limitations .","title":"tbdump"},{"location":"#faulty-application","text":"As an example let's take this code of a simple calculator: import sys def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) It will certainly raise an exception when divisor is 0. python divide.py 5 0 Traceback (most recent call last): File \"divide.py\", line 9, in <module> print(div(x, y)) File \"divide.py\", line 4, in div return x / y ZeroDivisionError: division by zero","title":"Faulty Application"},{"location":"#traceback-capturing","text":"We have following options to take traceback down into a file: We can use tbdump module in place of python interpreter. This will capture any unhandled Exception : python -m tbdump divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl It is suitable when we have a chance to change the way how Python script is invoked. This is also how tbdump can be activated from shebang: #!/usr/bin/env -S python -m tbdump Alternatively we can install tbdump as exception hook using its default implementation: import sys import tbdump tbdump . set_excepthook () def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl Finally, we can customize exception handler by preparing its custom implementation: import sys from tbdump import dump_exception def div ( x , y ): return x / y if __name__ == '__main__' : try : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) except Exception as exc : try : dumpfile = 'traceback.pkl' dump_exception ( exc , dumpfile ) print ( f ' { type ( exc ) . __name__ } : { exc } ' ) print ( f 'Traceback dumped into: { dumpfile } ' ) except Exception : print ( 'Failed to dump traceback' ) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl No matter which option we choose, we should get a traceback.pkl file in case of an exception.","title":"Traceback Capturing"},{"location":"#traceback-analysis","text":"Some developers may prefer to launch their favourite debugger right away: poetry run python -m tbdebug traceback.pkl tbdebug uses breakpoint() . Behaviour of this function can be adjusted using PYTHONBREAKPOINT variable. Alternatively, simple helper script can be used by hose who would like to apply any preprocessing in prior to that: import tbdump dump = tbdump . load ( 'traceback.pkl' ) # any preprocessing here breakpoint () Last option is for these developers who are familiar with peepshow and may prefer calling it: poetry run python -m tbpeep traceback.pkl","title":"Traceback Analysis"},{"location":"#limitations","text":"There are a few data types which dill doesn't pickle by definition. At the time of writing these include generator, Frame, Traceback. Note Top-level traceback and corresponding frames are translated into substitutionary objects. Moreover, there are a few open issues with pickling enums and namespace packages . Last but not least, modules which were captured on a remote host but are not available in local environment are substituted by dummy objects in the process of loading dump files.","title":"Limitations"},{"location":"api/","text":"API \u00b6 \u00b6 dump_exception ( exc , filename = 'traceback.pkl' , start_from = None ) \u00b6 Dump exception object and corresponding crash information into a file. Parameters: Name Type Description Default exc Exception Exception object with traceback. required filename str Target file name or path. 'traceback.pkl' start_from str Name of the source file to be considered as topmost. None Source code in tbdump/dumper.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def dump_exception ( exc : Exception , filename : str = DEFAULT_DUMP_NAME , start_from : str = None ) -> None : \"\"\"Dump exception object and corresponding crash information into a file. Arguments: exc: Exception object with traceback. filename: Target file name or path. start_from: Name of the source file to be considered as topmost. \"\"\" report = report_header () report [ 'exceptions' ] = exception_stack_info ( exc ) if start_from : last_exc = report [ 'exceptions' ][ - 1 ] while last_exc : if last_exc [ 0 ] . _filename == start_from : break del last_exc [ 0 ] with open ( filename , 'wb' ) as f : dill . dump ( report , f ) set_excepthook ( filename = 'traceback.pkl' , replace = True , silent = False ) \u00b6 Install tbdump as an exception handler. Parameters: Name Type Description Default filename str File name or path to the dump file. 'traceback.pkl' replace bool Set False to call original exception handler after tbdump. True silent bool Set True to suppress messages. False Source code in tbdump/dumper.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def set_excepthook ( filename : str = DEFAULT_DUMP_NAME , replace : bool = True , silent : bool = False ) -> None : \"\"\"Install tbdump as an exception handler. Arguments: filename: File name or path to the dump file. replace: Set `False` to call original exception handler after tbdump. silent: Set `True` to suppress messages. \"\"\" old_excepthook = sys . excepthook if silent : say = lambda text : None else : say = lambda text : print ( text , file = sys . stderr ) def tbdump_except_hook ( exctype , exc , traceback ): say ( exctype . __name__ + ': ' + str ( exc )) try : dump_exception ( exc , filename ) say ( 'Traceback dumped into: ' + filename ) except Exception : if int ( os . getenv ( 'TBDUMP_DEBUG' , '0' )): raise say ( 'Failed to dump traceback' ) if not replace : old_excepthook ( exctype , exc , traceback ) sys . excepthook = tbdump_except_hook \u00b6 load ( filename = 'traceback.pkl' ) \u00b6 Load crash information from a dump file. Parameters: Name Type Description Default filename str File name or path to be loded. 'traceback.pkl' Returns: Type Description dict Crash information. Source code in tbdump/loader.py 50 51 52 53 54 55 56 57 58 59 60 61 def load ( filename : str = DEFAULT_DUMP_NAME ) -> dict : \"\"\"Load crash information from a dump file. Arguments: filename: File name or path to be loded. Returns: Crash information. \"\"\" with DummyModuleFactory (): with open ( filename , 'rb' ) as f : return dill . load ( f )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#tbdump.dumper","text":"","title":"tbdump.dumper"},{"location":"api/#tbdump.dumper.dump_exception","text":"Dump exception object and corresponding crash information into a file. Parameters: Name Type Description Default exc Exception Exception object with traceback. required filename str Target file name or path. 'traceback.pkl' start_from str Name of the source file to be considered as topmost. None Source code in tbdump/dumper.py 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 def dump_exception ( exc : Exception , filename : str = DEFAULT_DUMP_NAME , start_from : str = None ) -> None : \"\"\"Dump exception object and corresponding crash information into a file. Arguments: exc: Exception object with traceback. filename: Target file name or path. start_from: Name of the source file to be considered as topmost. \"\"\" report = report_header () report [ 'exceptions' ] = exception_stack_info ( exc ) if start_from : last_exc = report [ 'exceptions' ][ - 1 ] while last_exc : if last_exc [ 0 ] . _filename == start_from : break del last_exc [ 0 ] with open ( filename , 'wb' ) as f : dill . dump ( report , f )","title":"dump_exception()"},{"location":"api/#tbdump.dumper.set_excepthook","text":"Install tbdump as an exception handler. Parameters: Name Type Description Default filename str File name or path to the dump file. 'traceback.pkl' replace bool Set False to call original exception handler after tbdump. True silent bool Set True to suppress messages. False Source code in tbdump/dumper.py 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 def set_excepthook ( filename : str = DEFAULT_DUMP_NAME , replace : bool = True , silent : bool = False ) -> None : \"\"\"Install tbdump as an exception handler. Arguments: filename: File name or path to the dump file. replace: Set `False` to call original exception handler after tbdump. silent: Set `True` to suppress messages. \"\"\" old_excepthook = sys . excepthook if silent : say = lambda text : None else : say = lambda text : print ( text , file = sys . stderr ) def tbdump_except_hook ( exctype , exc , traceback ): say ( exctype . __name__ + ': ' + str ( exc )) try : dump_exception ( exc , filename ) say ( 'Traceback dumped into: ' + filename ) except Exception : if int ( os . getenv ( 'TBDUMP_DEBUG' , '0' )): raise say ( 'Failed to dump traceback' ) if not replace : old_excepthook ( exctype , exc , traceback ) sys . excepthook = tbdump_except_hook","title":"set_excepthook()"},{"location":"api/#tbdump.loader","text":"","title":"tbdump.loader"},{"location":"api/#tbdump.loader.load","text":"Load crash information from a dump file. Parameters: Name Type Description Default filename str File name or path to be loded. 'traceback.pkl' Returns: Type Description dict Crash information. Source code in tbdump/loader.py 50 51 52 53 54 55 56 57 58 59 60 61 def load ( filename : str = DEFAULT_DUMP_NAME ) -> dict : \"\"\"Load crash information from a dump file. Arguments: filename: File name or path to be loded. Returns: Crash information. \"\"\" with DummyModuleFactory (): with open ( filename , 'rb' ) as f : return dill . load ( f )","title":"load()"}]}