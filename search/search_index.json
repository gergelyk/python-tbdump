{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"tibidi \u00b6 The aim of this library is to provide an option of post-mortem debugging for the application which would crash on a remote machine, for instance on customer site. Project is influenced by pydump and powered by cloudpickle . Faulty Application \u00b6 As an example let's take this code of a simple calculator: import sys def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) It will certainly raise an exception when divisor is 0. python divide.py 5 0 Traceback (most recent call last): File \"divide.py\", line 9, in <module> print(div(x, y)) File \"divide.py\", line 4, in div return x / y ZeroDivisionError: division by zero Traceback Capturing \u00b6 We have following options to take traceback down into a file: We can use tbdump module in place of python interpreter. This will capture any unhandled Exception : python -m tbdump divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl It is suitable when we have a chance to change the way how Python script is invoked. This is also how tbdump can be activated from shebang: #!/usr/bin/env -S python -m tbdump Alternatively we can install tbdump as exception hook using its default implementation: import sys import tibidi tibidi . set_excepthook () def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl Finally, we can customize exception handler by preparing its custom implementation: import sys from tibidi import dump_exception def div ( x , y ): return x / y if __name__ == '__main__' : try : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) except Exception as exc : try : dumpfile = 'traceback.pkl' dump_exception ( exc , dumpfile ) print ( f ' { type ( exc ) . __name__ } : { exc } ' ) print ( f 'Traceback dumped into: { dumpfile } ' ) except Exception : print ( 'Failed to dump traceback' ) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl No matter which option we choose, we should get a traceback.pkl file in case of an exception. Traceback Analysis \u00b6 Some developers may prefer to launch their favourite debugger right away: poetry run python -m tbdebug traceback.pkl tbdebug uses breakpoint() . Behaviour of this function can be adjusted using PYTHONBREAKPOINT variable. Alternatively, simple helper script can be used by hose who would like to apply any preprocessing in prior to that: import tibidi dump = tibidi . load ( 'traceback.pkl' ) # any preprocessing here breakpoint () Last option is for these developers who are familiar with peepshow and may prefer calling it: poetry run python -m tbpeep traceback.pkl Limitations \u00b6 There are a few data types which cannot be pickled. At the time of writing these include generator , Frame , Traceback . Therefore top-level traceback and corresponding frames are translated into substitutionary objects. Remaining objects of illegal types are replaced by objects of NotPickleable type. List of illegal types can be extended by registering custom islegal function: import tibidi tibidi . config . islegal = lambda obj : not isinstance ( obj , ( SomeType , AnotherType )) There are also a few objects which are recognized by cloudpickle as illegal, e.g. sys.stdin . This kind of objects are replaced by instances of Dummy class, which contains error message which explains what has happend during pickling process. Last but not least, modules which were captured on a remote host but are not available in local environment are substituted by objects of ModuleStub type in the process of loading dump files. Some of the objects may still cause problems in pickling process, or during loading them back. These objects can be covered by islegal as described above. More information about problems with pickling can be obtained by setting: import tibidi tibidi . config . debug = True","title":"Overview"},{"location":"#tibidi","text":"The aim of this library is to provide an option of post-mortem debugging for the application which would crash on a remote machine, for instance on customer site. Project is influenced by pydump and powered by cloudpickle .","title":"tibidi"},{"location":"#faulty-application","text":"As an example let's take this code of a simple calculator: import sys def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) It will certainly raise an exception when divisor is 0. python divide.py 5 0 Traceback (most recent call last): File \"divide.py\", line 9, in <module> print(div(x, y)) File \"divide.py\", line 4, in div return x / y ZeroDivisionError: division by zero","title":"Faulty Application"},{"location":"#traceback-capturing","text":"We have following options to take traceback down into a file: We can use tbdump module in place of python interpreter. This will capture any unhandled Exception : python -m tbdump divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl It is suitable when we have a chance to change the way how Python script is invoked. This is also how tbdump can be activated from shebang: #!/usr/bin/env -S python -m tbdump Alternatively we can install tbdump as exception hook using its default implementation: import sys import tibidi tibidi . set_excepthook () def div ( x , y ): return x / y if __name__ == '__main__' : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl Finally, we can customize exception handler by preparing its custom implementation: import sys from tibidi import dump_exception def div ( x , y ): return x / y if __name__ == '__main__' : try : x = int ( sys . argv [ 1 ]) y = int ( sys . argv [ 2 ]) print ( div ( x , y )) except Exception as exc : try : dumpfile = 'traceback.pkl' dump_exception ( exc , dumpfile ) print ( f ' { type ( exc ) . __name__ } : { exc } ' ) print ( f 'Traceback dumped into: { dumpfile } ' ) except Exception : print ( 'Failed to dump traceback' ) python divide.py 5 0 ZeroDivisionError: division by zero Traceback dumped into: traceback.pkl No matter which option we choose, we should get a traceback.pkl file in case of an exception.","title":"Traceback Capturing"},{"location":"#traceback-analysis","text":"Some developers may prefer to launch their favourite debugger right away: poetry run python -m tbdebug traceback.pkl tbdebug uses breakpoint() . Behaviour of this function can be adjusted using PYTHONBREAKPOINT variable. Alternatively, simple helper script can be used by hose who would like to apply any preprocessing in prior to that: import tibidi dump = tibidi . load ( 'traceback.pkl' ) # any preprocessing here breakpoint () Last option is for these developers who are familiar with peepshow and may prefer calling it: poetry run python -m tbpeep traceback.pkl","title":"Traceback Analysis"},{"location":"#limitations","text":"There are a few data types which cannot be pickled. At the time of writing these include generator , Frame , Traceback . Therefore top-level traceback and corresponding frames are translated into substitutionary objects. Remaining objects of illegal types are replaced by objects of NotPickleable type. List of illegal types can be extended by registering custom islegal function: import tibidi tibidi . config . islegal = lambda obj : not isinstance ( obj , ( SomeType , AnotherType )) There are also a few objects which are recognized by cloudpickle as illegal, e.g. sys.stdin . This kind of objects are replaced by instances of Dummy class, which contains error message which explains what has happend during pickling process. Last but not least, modules which were captured on a remote host but are not available in local environment are substituted by objects of ModuleStub type in the process of loading dump files. Some of the objects may still cause problems in pickling process, or during loading them back. These objects can be covered by islegal as described above. More information about problems with pickling can be obtained by setting: import tibidi tibidi . config . debug = True","title":"Limitations"},{"location":"api/","text":"API \u00b6 \u00b6 dump_exception ( exc , filename = 'traceback.pkl' , start_from = None ) \u00b6 Dump exception object and corresponding crash information into a file. Parameters: Name Type Description Default exc Exception Exception object with traceback. required filename str Target file name or path. 'traceback.pkl' start_from str Name of the source file to be considered as topmost. None Source code in tibidi/dumper.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def dump_exception ( exc : Exception , filename : str = DEFAULT_DUMP_NAME , start_from : str = None ) -> None : \"\"\"Dump exception object and corresponding crash information into a file. Arguments: exc: Exception object with traceback. filename: Target file name or path. start_from: Name of the source file to be considered as topmost. \"\"\" report = report_header () report [ 'exceptions' ] = exception_stack_info ( exc ) if start_from : last_exc = report [ 'exceptions' ][ - 1 ] while last_exc : if last_exc [ 0 ] . _filename == start_from : break del last_exc [ 0 ] with open ( filename , 'wb' ) as f : pickler . dump ( report , f ) set_excepthook ( filename = 'traceback.pkl' , replace = True , silent = False ) \u00b6 Install tbdump as an exception handler. Parameters: Name Type Description Default filename str File name or path to the dump file. 'traceback.pkl' replace bool Set False to call original exception handler after tbdump. True silent bool Set True to suppress messages. False Source code in tibidi/dumper.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_excepthook ( filename : str = DEFAULT_DUMP_NAME , replace : bool = True , silent : bool = False ) -> None : \"\"\"Install tbdump as an exception handler. Arguments: filename: File name or path to the dump file. replace: Set `False` to call original exception handler after tbdump. silent: Set `True` to suppress messages. \"\"\" old_excepthook = sys . excepthook if silent : say = lambda text : None else : say = lambda text : print ( text , file = sys . stderr ) def tbdump_except_hook ( exctype , exc , traceback ): say ( exctype . __name__ + ': ' + str ( exc )) try : dump_exception ( exc , filename ) say ( 'Traceback dumped into: ' + filename ) except Exception : if config . debug : raise say ( 'Failed to dump traceback' ) if not replace : old_excepthook ( exctype , exc , traceback ) sys . excepthook = tbdump_except_hook \u00b6 load ( filename = 'traceback.pkl' ) \u00b6 Load crash information from a dump file. Parameters: Name Type Description Default filename str File name or path to be loded. 'traceback.pkl' Returns: Type Description dict Crash information. Source code in tibidi/loader.py 42 43 44 45 46 47 48 49 50 51 52 53 def load ( filename : str = DEFAULT_DUMP_NAME ) -> dict : \"\"\"Load crash information from a dump file. Arguments: filename: File name or path to be loded. Returns: Crash information. \"\"\" with DummyModuleFactory (): with open ( filename , 'rb' ) as f : return pickler . load ( f )","title":"API"},{"location":"api/#api","text":"","title":"API"},{"location":"api/#tibidi.dumper","text":"","title":"tibidi.dumper"},{"location":"api/#tibidi.dumper.dump_exception","text":"Dump exception object and corresponding crash information into a file. Parameters: Name Type Description Default exc Exception Exception object with traceback. required filename str Target file name or path. 'traceback.pkl' start_from str Name of the source file to be considered as topmost. None Source code in tibidi/dumper.py 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 def dump_exception ( exc : Exception , filename : str = DEFAULT_DUMP_NAME , start_from : str = None ) -> None : \"\"\"Dump exception object and corresponding crash information into a file. Arguments: exc: Exception object with traceback. filename: Target file name or path. start_from: Name of the source file to be considered as topmost. \"\"\" report = report_header () report [ 'exceptions' ] = exception_stack_info ( exc ) if start_from : last_exc = report [ 'exceptions' ][ - 1 ] while last_exc : if last_exc [ 0 ] . _filename == start_from : break del last_exc [ 0 ] with open ( filename , 'wb' ) as f : pickler . dump ( report , f )","title":"dump_exception()"},{"location":"api/#tibidi.dumper.set_excepthook","text":"Install tbdump as an exception handler. Parameters: Name Type Description Default filename str File name or path to the dump file. 'traceback.pkl' replace bool Set False to call original exception handler after tbdump. True silent bool Set True to suppress messages. False Source code in tibidi/dumper.py 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 def set_excepthook ( filename : str = DEFAULT_DUMP_NAME , replace : bool = True , silent : bool = False ) -> None : \"\"\"Install tbdump as an exception handler. Arguments: filename: File name or path to the dump file. replace: Set `False` to call original exception handler after tbdump. silent: Set `True` to suppress messages. \"\"\" old_excepthook = sys . excepthook if silent : say = lambda text : None else : say = lambda text : print ( text , file = sys . stderr ) def tbdump_except_hook ( exctype , exc , traceback ): say ( exctype . __name__ + ': ' + str ( exc )) try : dump_exception ( exc , filename ) say ( 'Traceback dumped into: ' + filename ) except Exception : if config . debug : raise say ( 'Failed to dump traceback' ) if not replace : old_excepthook ( exctype , exc , traceback ) sys . excepthook = tbdump_except_hook","title":"set_excepthook()"},{"location":"api/#tibidi.loader","text":"","title":"tibidi.loader"},{"location":"api/#tibidi.loader.load","text":"Load crash information from a dump file. Parameters: Name Type Description Default filename str File name or path to be loded. 'traceback.pkl' Returns: Type Description dict Crash information. Source code in tibidi/loader.py 42 43 44 45 46 47 48 49 50 51 52 53 def load ( filename : str = DEFAULT_DUMP_NAME ) -> dict : \"\"\"Load crash information from a dump file. Arguments: filename: File name or path to be loded. Returns: Crash information. \"\"\" with DummyModuleFactory (): with open ( filename , 'rb' ) as f : return pickler . load ( f )","title":"load()"}]}